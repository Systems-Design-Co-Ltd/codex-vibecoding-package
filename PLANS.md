````markdown
# Codex 実行計画 (ExecPlans):
 
このドキュメントは、コーディングエージェントが動作する機能やシステム変更を提供するために従うべき実行計画（"ExecPlan"）の要件を説明します。読者をこのリポジトリの完全な初心者として扱ってください。読者は現在の作業ツリーと提供された単一の ExecPlan ファイルのみを持っています。以前の計画の記憶も外部コンテキストもありません。
 
## ExecPlans と PLANS.md の使い方
 
- 実行可能な仕様（ExecPlan）を作成する際は、PLANS.md に_一字一句_従ってください。
- 実行可能な仕様（ExecPlan）がコンテキストにない場合は、PLANS.md ファイル全体を読んで記憶を更新してください。
- 正確な仕様（ExecPlan）を作成するために、ソース資料を徹底的に読み（そして再読し）てください。
- 実行可能な仕様（ExecPlan）を作成する際は、このひな形から始めて、調査しながら修正および肉付けしてください。
- 実行可能な仕様 (ExecPlan) を実装する際は、「次のステップ」をユーザーにプロンプトしないでください；単に次のマイルストーンに進んでください。すべてのセクションを最新に保ち、停止するたびにリストにエントリを追加または分割して、進捗と次のステップを肯定的に述べます。曖昧さを自律的に解決し、頻繁にコミットしてください。

- 実行可能な仕様 (ExecPlan) を議論する際は、仕様にログを記録して将来のために保存してください；仕様が変更された理由が明確にわかるようにしてください。ExecPlans は生きている文書であり、常に ExecPlan と他の作業なしで再開できるようにしてください。

 
実行可能な仕様（ExecPlan）を実装する際は、ユーザーに「次のステップ」を促さず、単に次のマイルストーンに進んでください。すべてのセクションを最新の状態に保ち、すべての停止ポイントでリスト内のエントリを追加または分割して、進捗と次のステップを明確に示してください。曖昧さを自律的に解決し、頻繁にコミットしてください。
 
実行可能な仕様（ExecPlan）について議論する際は、後世のために仕様内のログに決定を記録してください。仕様への変更がなぜ行われたかが明確でなければなりません。ExecPlans は生きたドキュメントであり、_ExecPlan のみ_から、他の作業なしで常に再開できるべきです。
 
困難な要件や重大な未知数のある設計を調査する際は、マイルストーンを使用してプルーフオブコンセプトや「トイ実装」などを実装し、ユーザーの提案が実現可能かどうかを検証できるようにしてください。ライブラリのソースコードを見つけるか取得して読み、深く調査し、より完全な実装を導くプロトタイプを含めてください。 
## 要件
 
譲れない要件：
 
* すべての ExecPlan は完全に自己完結していなければなりません。自己完結とは、現在の形式で初心者が成功するために必要なすべての知識と指示が含まれていることを意味します。
* すべての ExecPlan は生きたドキュメントです。貢献者は、進捗があったとき、発見があったとき、設計上の決定が確定したときに、それを改訂する必要があります。各改訂は完全に自己完結したままでなければなりません。
* すべての ExecPlan は、このリポジトリの事前知識がない完全な初心者が機能をエンドツーエンドで実装できるようにしなければなりません。
* すべての ExecPlan は、単に「定義を満たす」コード変更ではなく、実証可能に動作する振る舞いを生み出さなければなりません。
* すべての ExecPlan は、専門用語を平易な言葉で定義するか、使用しないでください。
 
目的と意図が最優先です。まず、数文で、ユーザーの視点からなぜこの作業が重要なのかを説明してください。この変更後に誰かができるようになることで、変更前にはできなかったこと、そしてそれが動作していることをどのように確認するかを説明します。次に、読者をその結果を達成するための正確なステップへと導きます。何を編集し、何を実行し、何を観察すべきかを含めてください。
 
計画を実行するエージェントは、ファイルのリスト表示、ファイルの読み取り、検索、プロジェクトの実行、テストの実行ができます。エージェントは以前のコンテキストを知らず、以前のマイルストーンからあなたが意図したことを推測できません。依存する前提をすべて繰り返してください。外部のブログやドキュメントを指し示さないでください。知識が必要な場合は、自分の言葉で計画自体に埋め込んでください。ExecPlan が以前の ExecPlan の上に構築され、そのファイルがチェックインされている場合は、参照して組み込んでください。そうでない場合は、その計画からの関連するすべてのコンテキストを含める必要があります。
 
## フォーマット
 
フォーマットと構造はシンプルで厳密です。各 ExecPlan は、三重バッククォートで始まり終わる、`md` とラベル付けされた単一のフェンスコードブロックでなければなりません。内部に追加の三重バッククォートコードフェンスをネストしないでください。コマンド、トランスクリプト、差分、またはコードを示す必要がある場合は、その単一のフェンス内でインデントされたブロックとして提示してください。ExecPlan のコードフェンスを早期に閉じないように、ExecPlan 内部のコードフェンスの代わりにインデントを使用して明確にしてください。すべての見出しの後に 2 つの改行を使用し、# と ## などを使用し、順序付きリストと順序なしリストの正しい構文を使用してください。
 
ExecPlan がマークダウン (.md) ファイルに書き込まれ、ファイルの内容が_単一の ExecPlan のみ_である場合は、三重バッククォートを省略する必要があります。
 
平易な散文で書いてください。リストよりも文章を好んでください。簡潔さが意味を曖昧にする場合を除き、チェックリスト、表、長い列挙は避けてください。チェックリストは `Progress` セクションでのみ許可され、そこでは必須です。物語セクションは散文優先のままでなければなりません。
 
## ガイドライン
 
自己完結性と平易な言葉が最も重要です。通常の英語ではないフレーズ（「デーモン」、「ミドルウェア」、「RPC ゲートウェイ」、「フィルターグラフ」）を導入する場合は、すぐに定義し、それがこのリポジトリでどのように現れるかを読者に思い出させてください（例えば、それが現れるファイルやコマンドに名前を付けることによって）。「以前に定義されたように」や「アーキテクチャドキュメントによれば」とは言わないでください。自分自身を繰り返す場合でも、必要な説明をここに含めてください。
 
一般的な失敗モードを避けてください。未定義の専門用語に依存しないでください。結果のコードがコンパイルされるが意味のあることを何もしないほど狭く「機能の文字通り」を説明しないでください。重要な決定を読者に外注しないでください。曖昧さが存在する場合は、計画自体でそれを解決し、なぜそのパスを選択したかを説明してください。ユーザーに見える効果を過度に説明し、付随的な実装の詳細を過少に指定する側に誤ってください。
 
観察可能な結果で計画を固定してください。実装後にユーザーができること、実行するコマンド、表示されるべき出力を述べてください。受入は、内部属性（「HealthCheck 構造体を追加した」）ではなく、人間が検証できる振る舞い（「サーバーを起動した後、[http://localhost:8080/health](http://localhost:8080/health) にナビゲートすると、本文 OK で HTTP 200 が返される」）として表現する必要があります。変更が内部的である場合は、その影響がどのように実証できるかを説明してください（例えば、変更前に失敗し変更後に合格するテストを実行することによって、また新しい振る舞いを使用するシナリオを示すことによって）。
 
リポジトリコンテキストを明示的に指定してください。完全なリポジトリ相対パスでファイルに名前を付け、関数とモジュールを正確に名前付けし、新しいファイルを作成する場所を説明してください。複数の領域に触れる場合は、初心者が自信を持ってナビゲートできるように、それらの部分がどのように組み合わさるかを説明する短いオリエンテーション段落を含めてください。コマンドを実行する際は、作業ディレクトリと正確なコマンドラインを示してください。結果が環境に依存する場合は、前提を述べ、合理的な場合は代替案を提供してください。
 
べき等で安全であってください。ステップを複数回実行しても損傷やドリフトが発生しないように記述してください。ステップが途中で失敗する可能性がある場合は、再試行または適応する方法を含めてください。移行または破壊的な操作が必要な場合は、バックアップまたは安全なフォールバックを明記してください。進行中に検証できる、加算的でテスト可能な変更を好んでください。
 
検証はオプションではありません。テストを実行し、該当する場合はシステムを起動し、何か有用なことをしているのを観察する指示を含めてください。新しい機能や機能の包括的なテストを説明してください。初心者が成功と失敗を区別できるように、期待される出力とエラーメッセージを含めてください。可能であれば、変更がコンパイルを超えて効果的であることを証明する方法を示してください（例えば、小さなエンドツーエンドシナリオ、CLI 呼び出し、または HTTP リクエスト/レスポンストランスクリプトを通じて）。プロジェクトのツールチェーンに適切な正確なテストコマンドと、その結果をどのように解釈するかを述べてください。
 
証拠を捕らえてください。ステップがターミナル出力、短い差分、またはログを生成する場合は、単一のフェンスブロック内にインデントされた例として含めてください。それらを簡潔に保ち、成功を証明するものに焦点を当ててください。パッチを含める必要がある場合は、大きなブロブを貼り付けるのではなく、読者があなたの指示に従って再作成できるファイルスコープの差分または小さな抜粋を好んでください。
 
## マイルストーン
 
マイルストーンは官僚主義ではなく物語です。作業をマイルストーンに分割する場合は、各マイルストーンに、スコープ、マイルストーンの終わりに以前は存在しなかったものが何になるか、実行するコマンド、観察すると予想される受入を説明する簡単な段落を導入してください。ストーリーとして読めるようにしてください：目標、作業、結果、証明。進捗とマイルストーンは異なります：マイルストーンは物語を語り、進捗は詳細な作業を追跡します。両方が存在しなければなりません。簡潔さのためだけにマイルストーンを省略したり、将来の実装に重要な詳細を省略したりしないでください。
 
各マイルストーンは独立して検証可能で、実行計画の全体的な目標を段階的に実装する必要があります。
 
## 生きた計画と設計上の決定
 
* ExecPlans は生きたドキュメントです。重要な設計上の決定を行う際は、決定とその背後にある考えの両方を記録するように計画を更新してください。すべての決定を `Decision Log` セクションに記録してください。
* ExecPlans には、`Progress` セクション、`Surprises & Discoveries` セクション、`Decision Log`、および `Outcomes & Retrospective` セクションが含まれ、維持されなければなりません。これらはオプションではありません。
* オプティマイザーの振る舞い、パフォーマンストレードオフ、予期しないバグ、またはアプローチを形作った逆/非適用セマンティクスを発見した場合は、短い証拠スニペット（テスト出力が理想的）とともに `Surprises & Discoveries` セクションにそれらの観察を捕らえてください。
* 実装の途中でコースを変更する場合は、なぜそうしたかを `Decision Log` に文書化し、その影響を `Progress` に反映してください。計画は、チェックリストであると同時に、次の貢献者へのガイドです。
* 主要なタスクまたは完全な計画の完了時に、達成されたこと、残っていること、学んだ教訓を要約する `Outcomes & Retrospective` エントリを書いてください。
 
# プロトタイピングマイルストーンと並行実装
 
より大きな変更のリスクを軽減する場合、明示的なプロトタイピングマイルストーンを含めることは許容されます——そしてしばしば奨励されます。例：実現可能性を検証するために依存関係に低レベルオペレーターを追加する、またはオプティマイザー効果を測定しながら 2 つの構成順序を探索する。プロトタイプを加算的でテスト可能に保ってください。スコープを「プロトタイピング」として明確にラベル付けし、実行方法と結果の観察方法を説明し、プロトタイプを昇格または破棄する基準を述べてください。
 
テストが合格し続ける加算的なコード変更の後に減算を行うことを好んでください。並行実装（例えば、大規模な移行中にテストが合格し続けることを可能にするために、古いパスと一緒にアダプターを保持する）は、リスクを減らしたり、大規模な移行中にテストが合格し続けることを可能にしたりする場合は問題ありません。両方のパスを検証する方法と、テストを使用して安全に 1 つを廃止する方法を説明してください。複数の新しいライブラリまたは機能領域を扱う場合は、これらの機能の実現可能性を_互いに独立して_評価するスパイクを作成することを検討してください。外部ライブラリが期待どおりに動作し、分離して必要な機能を実装することを証明してください。
 
## 優れた ExecPlan のスケルトン
 
```md
# <短く、アクション指向の説明>
 
この ExecPlan は生きたドキュメントです。作業が進むにつれて、`Progress`、`Surprises & Discoveries`、`Decision Log`、および `Outcomes & Retrospective` のセクションを最新の状態に保つ必要があります。
 
PLANS.md ファイルがリポジトリにチェックインされている場合は、リポジトリルートからそのファイルへのパスをここで参照し、このドキュメントが PLANS.md に従って維持されなければならないことを記してください。
 
## Purpose / Big Picture（目的 / 全体像）
 
この変更後に誰かが何を得るか、そしてそれが動作していることをどのように確認できるかを数文で説明してください。有効にするユーザーに見える振る舞いを述べてください。
 
## Progress（進捗）
 
チェックボックス付きのリストを使用して、詳細なステップを要約してください。すべての停止ポイントをここに文書化する必要があります。たとえ部分的に完了したタスクを 2 つ（「完了」対「残り」）に分割する必要がある場合でも。このセクションは常に作業の実際の現在の状態を反映する必要があります。
 
- [x] (2025-10-01 13:00Z) 完了したステップの例。
- [ ] 未完了のステップの例。
- [ ] 部分的に完了したステップの例（完了：X、残り：Y）。
 
タイムスタンプを使用して進捗率を測定してください。
 
## Surprises & Discoveries（驚きと発見）
 
実装中に発見された予期しない振る舞い、バグ、最適化、または洞察を文書化してください。簡潔な証拠を提供してください。
 
- - 観察：…
  証拠：…
 
## Decision Log（決定ログ）
 
計画に取り組んでいる間に行われたすべての決定を次の形式で記録してください：
 
- 決定：…
  根拠：…
  日付/作成者：…
 
## Outcomes & Retrospective（結果と振り返り）
 
主要なマイルストーンまたは完了時に、結果、ギャップ、学んだ教訓を要約してください。結果を元の目的と比較してください。
 
## Context and Orientation（コンテキストとオリエンテーション）
 
読者が何も知らないかのように、このタスクに関連する現在の状態を説明してください。完全なパスで主要なファイルとモジュールに名前を付けてください。使用する明白でない用語を定義してください。以前の計画を参照しないでください。
 
## Plan of Work（作業計画）
 
散文で、編集と追加のシーケンスを説明してください。各編集について、ファイルと場所（関数、モジュール）、および何を挿入または変更するかを名前付けてください。具体的で最小限に保ってください。
 
## Concrete Steps（具体的なステップ）
 
実行する正確なコマンドとそれらを実行する場所（作業ディレクトリ）を述べてください。コマンドが出力を生成する場合は、読者が比較できるように短い期待されるトランスクリプトを示してください。このセクションは作業が進むにつれて更新する必要があります。
 
## Validation and Acceptance（検証と受入）
 
システムを開始または動作させる方法と、何を観察するかを説明してください。受入を振る舞いとして、特定の入力と出力で表現してください。テストが含まれる場合は、「<プロジェクトのテストコマンド>を実行し、<N> 個が合格することを期待します。新しいテスト <名前> は変更前に失敗し、変更後に合格します」と言ってください。
 
## Idempotence and Recovery（べき等性と回復）
 
ステップを安全に繰り返すことができる場合は、そう言ってください。ステップがリスクがある場合は、安全な再試行またはロールバックパスを提供してください。完了後は環境をクリーンに保ってください。
 
## Artifacts and Notes（成果物とノート）
 
インデントされた例として、最も重要なトランスクリプト、差分、またはスニペットを含めてください。それらを簡潔に保ち、成功を証明するものに焦点を当ててください。
 
## Interfaces and Dependencies（インターフェースと依存関係）
 
規範的であってください。使用するライブラリ、モジュール、およびサービスに名前を付け、なぜそうするかを述べてください。マイルストーンの終わりに存在しなければならない型、トレイト/インターフェース、および関数シグネチャを指定してください。`crate::module::function` や `package.submodule.Interface` のような安定した名前とパスを好んでください。例：
 
crates/foo/planner.rs で、次を定義してください：
 
    pub trait Planner {
        fn plan(&self, observed: &Observed) -> Vec<Action>;
    }
```
 
```
 
上記のガイダンスに従えば、単一のステートレスエージェント——または人間の初心者——があなたの ExecPlan を上から下まで読んで、動作する観察可能な結果を生み出すことができます。それが基準です：自己完結、自己充足、初心者ガイド、結果重視。
 
計画を改訂する際は、生きたドキュメントのセクションを含むすべてのセクションに変更が包括的に反映されていることを確認する必要があり、計画の最後に変更とその理由を説明するメモを書く必要があります。ExecPlans は何をすべきかだけでなく、ほぼすべてにおいてなぜそうするのかを説明しなければなりません。
````

